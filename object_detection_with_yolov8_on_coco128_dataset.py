# -*- coding: utf-8 -*-
"""Object Detection with YOLOv8 on COCO128 Dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yC6gPXDRNBrlSU1g8mMI-R8ArNux4ECN
"""

# yolov8_coco128_training.py

# Step 1: Install dependencies
!pip install ultralytics -q

# Step 2: Import and prepare YOLOv8
from ultralytics import YOLO
from ultralytics.utils.downloads import download
import os
import shutil

# Step 3: Download COCO128 dataset
if not os.path.exists("coco128"):
    download('https://github.com/ultralytics/yolov5/releases/download/v1.0/coco128.zip', unzip=True)

# Step 4: Train YOLOv8 on COCO128
yolo_model = YOLO('yolov8n.pt')  # nano model: fast, lightweight

yolo_model.train(
    data='ultralytics/cfg/datasets/coco128.yaml',
    epochs=10,
    imgsz=640,
    name='yolov8_coco128_exp'
)

# Step 5: Evaluate the model and print key metrics
metrics = yolo_model.val()

print("üìä Evaluation Metrics:")
print("‚úÖ mAP@0.5:", metrics.box.map50)
print("‚úÖ mAP@0.5:0.95:", metrics.box.map)
print("‚úÖ Precision:", metrics.box.mp)
print("‚úÖ Recall:", metrics.box.mr)

# Step 6: Inference on sample images and save detections
predict_folder_name = 'predict_images'
results = yolo_model.predict(
    source='coco128/images/train2017',
    save=True,
    imgsz=640,
    conf=0.25,
    name=predict_folder_name
)

# Step 7: Copy 10 sample detection images to a new folder for report use
source_folder = f'runs/detect/{predict_folder_name}'
sample_folder = 'runs/detect/samples'
os.makedirs(sample_folder, exist_ok=True)

image_files = [f for f in os.listdir(source_folder) if f.lower().endswith(('.jpg', '.png'))][:10]

for img in image_files:
    shutil.copy(os.path.join(source_folder, img), os.path.join(sample_folder, img))

print(f"‚úÖ Sample detection images saved to: {sample_folder}")

# Step 8: Export to ONNX format (for deployment or GitHub submission)
yolo_model.export(format='onnx')

print("‚úÖ Model export to ONNX completed.")

from google.colab import files
files.download('/content/runs/detect/yolov8_coco128_exp/weights/best.pt')

import os
from IPython.display import Image, display
from glob import glob

# üîç Step 1: Find the most recent prediction folder
detect_dir = "/content/runs/detect/"
all_preds = sorted(glob(os.path.join(detect_dir, 'predict*')), key=os.path.getmtime, reverse=True)

if not all_preds:
    print("‚ùå No prediction folder found. Run yolo_model.predict() first.")
else:
    latest_pred_folder = all_preds[0]
    print(f"‚úÖ Found prediction folder: {latest_pred_folder}")

    # üì∏ Step 2: Collect the first 10 image paths
    image_files = sorted(glob(os.path.join(latest_pred_folder, '*.jpg')))[:10]

    if not image_files:
        print("‚ùå No prediction images found in the folder.")
    else:
        # üëÅÔ∏è Step 3: Display the images
        print(f"Showing {len(image_files)} images:")
        for img_path in image_files:
            display(Image(filename=img_path))

from google.colab import files

# Download each image file
for img_path in image_files:
    files.download(img_path)

from ultralytics import YOLO

model = YOLO('runs/detect/yolov8_coco128_exp/weights/best.pt')
results = model.predict(source='coco128/images/train2017', imgsz=640, conf=0.25)
import glob
import numpy as np
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import matplotlib.pyplot as plt
import os

# Prepare class IDs
true_classes = []
pred_classes = []

# Iterate over predictions and corresponding label files
for i, r in enumerate(results):
    # Get prediction classes
    pred_cls = r.boxes.cls.cpu().numpy().astype(int)

    # Get filename (without extension) to match label
    image_path = r.path
    image_id = os.path.splitext(os.path.basename(image_path))[0]
    label_file = f'coco128/labels/train2017/{image_id}.txt'

    if os.path.exists(label_file):
        with open(label_file, 'r') as f:
            lines = f.readlines()
            true_cls = [int(line.split()[0]) for line in lines]

            # Match number of predictions and truths for simplicity (optional: apply IoU matching)
            n = min(len(true_cls), len(pred_cls))
            true_classes.extend(true_cls[:n])
            pred_classes.extend(pred_cls[:n])
# Generate confusion matrix
cm = confusion_matrix(true_classes, pred_classes)

# Display confusion matrix
disp = ConfusionMatrixDisplay(confusion_matrix=cm)
disp.plot(cmap=plt.cm.Blues)
plt.title("YOLOv8 Confusion Matrix on COCO128")
plt.show()